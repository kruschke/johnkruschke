<HTML>
<HEAD>
<TITLE>Q550 (Connectionist) Models in Cognitive Science, Prof. Kruschke</TITLE>
</HEAD>
<BODY>
<hr>

<center>
<h2>
<a href="../index.html">Q550 (Connectionist) Models in Cognitive Science</a>
<br>Prof. John K. Kruschke
<p>Materials Accompanying J. A. Anderson Textbook
</h2>
</center>

<p>Retrieved via anonymous ftp from mitpress.mit.edu, directory
pub/Intro-to-NeuralNets

<p><pre>
                               Appendix E
                    Summed Vector Memory (Chapter 7)

     This program gives a demonstration of a simple summed vector 
recognition memory.  The memory (variable Memory) is a vector which
is the sum of the learned vectors.  In the program, the vectors 
have maximum dimensionality of 2,000 and the distribution of elements 
has mean zero and an average length of one.  The learned vectors are 
generated by the VAX library random number generator MTH$RANDOM which 
will have to be changed if another computer is used.

     When the program is run, the program will prompt for the seed 
for the random number generator, the dimensionality of the system 
(2,000 maximum) and the number of random vectors to learn (200 maximum).  
 
     The output of the system uses character based graphics to present 
the histogram of system output values when the vectors the system learned 
are tested, and when 100 new zero mean random vectors are tested.  New 
random vectors should give output values about zero; the learned vectors 
should give outputs around one.  The y-axis (vertical) gives the inner 
product value times 10; the x-axis (horizontal) gives the number of 
output values in the bin.  The program can be run again if wanted, by 
typing `y' to the prompt.

---------------------------------------------------------------------

PROGRAM SVDEMO (Input, Output);

CONST Max_Dimensionality = 2000;
      Number_in_test_set =  100;
      Number_to_learn    =  200;

TYPE Vector           = ARRAY [1..Max_Dimensionality] OF REAL;

VAR I, J, Seed, Number_of_vectors,
       Number_learned, Index, Dimensionality: INTEGER;
    Memory       : Vector;
    Test_vectors : ARRAY  [1..Number_in_test_set] OF Vector;
    F_vectors    : ARRAY  [1..Number_to_learn] OF Vector;
    TS_histogram,
    LS_histogram : ARRAY  [-20..20] OF INTEGER;
    Exit         : BOOLEAN;
    Input_char   : CHAR;


PROCEDURE GoToXY (X,Y: INTEGER);
   BEGIN
   WRITELN;
   WRITE (CHR (27), '[');
   IF Y<1 THEN Y:= 1; IF Y>24 THEN Y:= 24;
   IF X<1 THEN X:= 1; IF X>80 THEN X:= 80;
   IF Y<10 THEN WRITE (Y:1) ELSE WRITE (Y:2);
   WRITE (';');
   IF X<10 THEN WRITE (X:1) ELSE WRITE (X:2);
   WRITE ('H');
   END;

PROCEDURE Add_Vectors (Vector_1, Vector_2: Vector; 
                                VAR Vector_sum: Vector);
    VAR I: INTEGER;
    BEGIN
    FOR I:= 1 TO Dimensionality DO 
        Vector_sum [I] := Vector_1 [I] + Vector_2 [I];
    END;

FUNCTION Inner_product (Vector_1, Vector_2: Vector): REAL;
    VAR             I: INTEGER;
     Sum_of_products : REAL;
    BEGIN
    Sum_of_products := 0;
    FOR I:= 1 TO Dimensionality DO 
        Sum_of_products := Vector_1 [I] * Vector_2 [I] + Sum_of_products;
    Inner_product:= Sum_of_products;
    END;

FUNCTION Vector_length (Vector_1: Vector): REAL;
    VAR Sum_of_Squares: REAL;
                     I: INTEGER;
    BEGIN
    Sum_of_Squares:= 0;
    FOR I:= 1 TO Dimensionality DO 
        Sum_of_Squares := Vector_1 [I]*Vector_1 [I] + Sum_of_squares;
    Vector_length:= SQRT (Sum_of_Squares);
    END;

PROCEDURE Make_random_vector  (VAR V: Vector);

    {This procedure generates a random vector with average length one }
    {and zero mean.                                                   }

    VAR I: INTEGER;
        Sqrt_Dim: REAL;

    FUNCTION MTH$RANDOM (Seed: INTEGER): REAL; EXTERN;

    FUNCTION Random: REAL;
        BEGIN
        Random := MTH$RANDOM (Seed);
        END;

    BEGIN
    {Another way of making a vector of length 1.}
    Sqrt_dim:= SQRT(Dimensionality/12);
    FOR I:= 1 TO Dimensionality DO V[I]:= (Random - 0.5)/ Sqrt_dim;
    END; 

PROCEDURE Make_test_vectors;
  VAR I: INTEGER;
  BEGIN
  GoToXY (1,22);  WRITE ('Making test vectors   :         ');
  FOR I:= 1 TO Number_in_test_set DO
    BEGIN
    Make_random_vector (Test_vectors [I]);
    GoToXY (24,22);  
    WRITE (I:4); 
    WRITE (' Length: ', Vector_Length (Test_vectors[I]):10);
    END;
  END;

PROCEDURE Make_learned_vectors;
  VAR I: INTEGER;
  BEGIN
  GoToXY (1,23); WRITE  ('Making learned vectors:         ');
  FOR I:= 1 TO Number_of_vectors DO
    BEGIN
    Make_random_vector (F_vectors [I]);
    GoToXY (24,23);
    WRITE (I:4);
    WRITE (' Length: ',  Vector_Length (F_vectors[I]):10);
    END;
  END;

PROCEDURE Display_outputs;
  VAR I,J: INTEGER;
  Begin
  WRITE (CHR (27), '[f');   {To home.}
  WRITE (CHR (27), '[2J');  {erase screem.}
  GoTOXY (1,2);
  WRITELN  ('Inner product of learned Vectors (*) and  test vectors (+).');
  FOR I:= -5 TO 14 DO
      BEGIN
      WRITE (I:3,' ');
      FOR J:= 1 TO LS_Histogram [I] DO WRITE ('*');
      WRITELN;
      END;
  GoTOXY (1,2);
  WRITELN  ('Inner product of learned Vectors (*) and  test vectors (+).');
  FOR I:= -5 TO 14 DO
      BEGIN
      WRITE (I:3,' ');
      FOR J:= 1 TO TS_histogram [I] DO WRITE ('+');
      WRITELN;
      END;
  END;

PROCEDURE Initialize;
  VAR I: INTEGER;
  BEGIN
  GoToXY (0,0);
  WRITE (CHR(27), '[2J');
  WRITELN ;
  WRITELN ;
  WRITELN ('Demonstration of Simple Summed Vector Memory.'      );
  WRITELN ('Uses random vectors which are simply summed.'       );
  WRITELN ('Recall is tested using innerproducts of stored and' );
  WRITELN ('random vectors.'                                    );
  WRITELN ('Maximum Dimensionality is: ', Max_dimensionality:4  );
  WRITE   ('Seed                     : ');  READLN (Seed);
  WRITE   ('Dimensionality           : ');  READLN (Dimensionality);
  WRITE   ('Nr of vectors to learn   : ');  READLN (Number_of_vectors);
  WRITELN;
  FOR I:= -20 TO 20 DO BEGIN LS_Histogram [I]:= 0; TS_histogram [I]:= 0 END;
  FOR I:= 1 TO Dimensionality DO Memory [I]:= 0;
  Make_test_vectors;
  Make_learned_vectors;
  END;

PROCEDURE Demonstration;
  VAR I,J: INTEGER;
      Goodness_of_recall: REAL;

  BEGIN
  Initialize;
  GoToXY (1,1);  
  WRITE ('>> Learning.                ');
  GoToXY (1,12); WRITE (CHR(27), '[K');
  FOR I:= 1 TO Number_of_vectors DO
      BEGIN
      GoToXY (1,12);  
      Add_vectors (Memory, F_vectors [I], Memory);
      Goodness_of_recall:= Inner_product (Memory, F_vectors [I]);
      WRITELN ('Vectors learned : ', I:4, '  Recall of last vector: ',
               Goodness_of_recall:12);
      END;
  GoToXY (1,1);  
  WRITE ('>> Testing learned vectors after complete set is learned.');
  GoToXY (1,12); WRITE (CHR(27), '[K');
  FOR I:= 1 TO Number_of_vectors DO
      BEGIN
      GoToXY (1,12); 
      Goodness_of_recall:= Inner_product  (Memory, F_Vectors [I]);
      WRITELN ('Vectors tested  : ', I:4, '  Inner product        : ',
                Goodness_of_recall:12);
      Index:= ROUND (10 * Goodness_of_recall);
      LS_histogram [Index]:= LS_histogram [Index] + 1;
      END;
  GoToXY (1,1); 
  WRITE ('>> Using test vectors after complete set is learned.       ');
  GoToXY (1,12);  
  FOR I:=1 TO Number_in_test_set DO
      BEGIN
      GoToXY (1,12); 
      Goodness_of_recall:= Inner_product (Memory, Test_vectors [I]);
      WRITELN ('Vectors tested  : ',I:4, '  Inner product         : ',
                Goodness_of_recall:12);
      Index:= ROUND (10 * Goodness_of_recall);
      TS_histogram [Index]:= TS_histogram [Index] + 1;
      END;
  Display_outputs;
  GoToXY (1,1);
  WRITE  ('>> Do you want to repeat this demonstration? Y/N         ');
  READLN (Input_char);
  IF Input_char IN ['N','n'] THEN Exit:= TRUE ELSE Exit:= FALSE;
  END;

BEGIN {Main program.}
REPEAT Demonstration UNTIL Exit;
END. {Main program.}

</pre>
<p><hr>

</BODY>
</HTML>
